### **Задача: Система за изплащане на служители** 

### **(Java Streams и Полиморфизъм)**

#### **Сценарий**

Разполагате с три типа служители във фирма:

1. **Employee** – Абстрактен базов клас с:

   * `String name`  
   * `int id`  
   * Абстрактен метод: `double calculateMonthlyPay()`  
2. **FullTimeEmployee** – Наследява `Employee`:

   * Допълнително поле: `double annualSalary`  
   * Реализира `calculateMonthlyPay()`, като връща `annualSalary / 12`  
3. **PartTimeEmployee** – Наследява `Employee`:

   * Допълнителни полета: `double hourlyRate`, `int hoursPerMonth`  
   * Реализира `calculateMonthlyPay()`, като връща `hourlyRate * hoursPerMonth`

*(Може да добавите и други подтипове, например `Contractor`)*

Имате списък от обекти `Employee`, който може да включва както `FullTimeEmployee`, така и `PartTimeEmployee`.

---

1. **Създайте класовете**

   * Дефинирайте абстрактния клас `Employee` с неговите полета и поне един абстрактен метод `calculateMonthlyPay()`.  
   * Имплементирайте два конкретни подкласа: `FullTimeEmployee` и `PartTimeEmployee`, всеки от които да преодолее абстрактния метод и да изчислява месечното заплащане според описаната логика.  
2. **Инициализирайте данните**

   * Във вашия метод `main()` (или в тестови клас) създайте `List<Employee>` и добавете поне:  
     * 3–4 обекта `FullTimeEmployee` (например, с различни годишни заплати).  
     * 3–4 обекта `PartTimeEmployee` (с различни почасови ставки и часове на месец).  
3. **Използвайте Streams за обработка на списъка**

   * **Филтриране**

     * Намерете всички служители, чиято месечна заплата е **над** определен праг (примерно 3000).  
     * Изведете имената им и месечната им заплата.  
   * **Сортиране**

     * Сортирайте всички служители **низходящо** по месечна заплата.  
     * Изведете сортирания списък.  
   * **Мапване към низ (String)**

     * Използвайте `.map(...)`, за да превърнете всеки служител в низ, например: "ID:\<id\>,Име:\<name\>,Месечназаплата:\<calculateMonthlyPay()\>"   
     * Колекционирайте тези низове в `List<String>` и ги изведете.  
   * **Изчисляване на статистики**

     * Превърнете месечната заплата на всеки служител в `DoubleStream` (например, чрез `mapToDouble(Employee::calculateMonthlyPay)`).  
     * Използвайте `summaryStatistics()` (или отделни методи) за да покажете:  
       * **Средна месечна заплата**  
       * **Минимална заплата**  
       * **Максимална заплата**  
       * **Сума на всички месечни заплати**  
       * **Брой служители**  
   * **Допълнителни операции с Stream**

     * **anyMatch / allMatch / noneMatch**  
       * Проверете дали **има** служител с месечна заплата над 6000 (`anyMatch`),  
       * дали **всички** служители имат месечна заплата над 2000 (`allMatch`),  
       * и дали **няма** служител с месечна заплата под 500 (`noneMatch`).  
       * Изведете резултатите като булеви стойности или съобщения.  
     * **Пропускане и ограничаване** (`skip(...)`, `limit(...)`)  
       * Направете сортиран стрийм по низходяща месечна заплата, пропуснете първите 2 (`skip(2)`) и вземете следващите 3 (`limit(3)`), за да видите „средната класа“ (примерно).  
       * Изведете тяхната информация.  
     * **Натрупване с `reduce`**  
       * Използвайте `.reduce(...)` върху месечната заплата, за да намерите общата сума на заплатите (алтернативно на `summaryStatistics().getSum()`).  
       * Изведете резултата.  
4. **Бонус демонстрация на Полиморфизъм**

   * Добавете метод в класа `Employee`, например `String getRole()`, и го преодолеете в подкласа, за да връща `"FullTime"` или `"PartTime"`.  
   * Създайте стрийм от служители и групирайте по role чрез `Collectors.groupingBy(Employee::getRole)`, за да видите смисъла на полиморфизма.  
   * След това може да приложите и `Collectors.counting()` или `Collectors.summarizingDouble(...)` по групи, за да видите статистики спрямо ролята (FullTime / PartTime).  
5. **Бонус**

   * Намерете служител по име или по ID, като използвате `filter(...)` и `findFirst()`, за да получите `Optional<Employee>`.   
   * Ако няма такъв служител върнете първият в списъка, ако няма и такъв хвърлете изключение

---

